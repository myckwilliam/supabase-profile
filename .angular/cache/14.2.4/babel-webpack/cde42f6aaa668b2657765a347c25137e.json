{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    this._handleVisibilityChange();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(({\n        error\n      }) => {\n        if (error) {\n          throw new Error('Error getting session from URL.');\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n\n\n  signUp({\n    email,\n    password,\n    phone\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n          data: options.data,\n          captchaToken: options.captchaToken\n        }) : yield this.api.signUpWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          data: options.data,\n          captchaToken: options.captchaToken\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on sign up.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  signIn({\n    email,\n    phone,\n    password,\n    refreshToken,\n    provider,\n    oidc\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        if (email && !password) {\n          const {\n            error\n          } = yield this.api.sendMagicLinkEmail(email, {\n            redirectTo: options.redirectTo,\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (email && password) {\n          return this._handleEmailSignIn(email, password, {\n            redirectTo: options.redirectTo,\n            captchaToken: options.captchaToken\n          });\n        }\n\n        if (phone && !password) {\n          const {\n            error\n          } = yield this.api.sendMobileOTP(phone, {\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (phone && password) {\n          return this._handlePhoneSignIn(phone, password);\n        }\n\n        if (refreshToken) {\n          // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n          const {\n            error\n          } = yield this._callRefreshToken(refreshToken);\n          if (error) throw error;\n          return {\n            user: this.currentUser,\n            session: this.currentSession,\n            error: null\n          };\n        }\n\n        if (provider) {\n          return this._handleProviderSignIn(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n          });\n        }\n\n        if (oidc) {\n          return this._handleOpenIDConnectSignIn(oidc);\n        }\n\n        throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP(params, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = yield this.api.verifyOTP(params, options);\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n\n\n  user() {\n    return this.currentUser;\n  }\n  /**\n   * Returns the session data, if there is an active session.\n   */\n\n\n  session() {\n    return this.currentSession;\n  }\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n\n\n  refreshSession() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.'); // currentSession and currentUser will be updated to latest on _callRefreshToken\n\n        const {\n          error\n        } = yield this._callRefreshToken();\n        if (error) throw error;\n        return {\n          data: this.currentSession,\n          user: this.currentUser,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  update(attributes) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        const {\n          user,\n          error\n        } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n        if (error) throw error;\n        if (!user) throw Error('Invalid user data.');\n        const session = Object.assign(Object.assign({}, this.currentSession), {\n          user\n        });\n\n        this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED');\n\n        return {\n          data: user,\n          user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n\n\n  setSession(refresh_token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n\n        if (error) {\n          return {\n            session: null,\n            error: error\n          };\n        }\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e,\n          session: null\n        };\n      }\n    });\n  }\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n\n\n  setAuth(access_token) {\n    this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n      access_token,\n      token_type: 'bearer',\n      user: this.user()\n    });\n\n    this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n    return this.currentSession;\n  }\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n\n\n  getSessionFromUrl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new Error('No browser detected.');\n        const error_description = getParameterByName('error_description');\n        if (error_description) throw new Error(error_description);\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new Error('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new Error('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new Error('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new Error('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          user,\n          error\n        } = yield this.api.getUser(access_token);\n        if (error) throw error;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user: user\n        };\n\n        if (options === null || options === void 0 ? void 0 : options.storeSession) {\n          this._saveSession(session);\n\n          const recoveryMode = getParameterByName('type');\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          if (recoveryMode === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY');\n          }\n        } // Remove tokens from URL\n\n\n        window.location.hash = '';\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT');\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.api.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n\n\n  onAuthStateChange(callback) {\n    try {\n      const id = uuid();\n      const subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: subscription,\n        error: null\n      };\n    } catch (e) {\n      return {\n        data: null,\n        error: e\n      };\n    }\n  }\n\n  _handleEmailSignIn(email, password, options = {}) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          captchaToken: options.captchaToken\n        });\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handlePhoneSignIn(phone, password, options = {}) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithPhone(phone, password, options);\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    });\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n\n      return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n      return {\n        data: null,\n        user: null,\n        session: null,\n        error: e\n      };\n    }\n  }\n\n  _handleOpenIDConnectSignIn({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (id_token && nonce && (client_id && issuer || provider)) {\n        try {\n          const {\n            data,\n            error\n          } = yield this.api.signInWithOpenIDConnect({\n            id_token,\n            nonce,\n            client_id,\n            issuer,\n            provider\n          });\n          if (error || !data) return {\n            user: null,\n            session: null,\n            error\n          };\n\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          return {\n            user: data.user,\n            session: data,\n            error: null\n          };\n        } catch (e) {\n          return {\n            user: null,\n            session: null,\n            error: e\n          };\n        }\n      }\n\n      throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n    });\n  }\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n\n\n  _recoverSession() {\n    try {\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n      if (!data) return null;\n      const {\n        currentSession,\n        expiresAt\n      } = data;\n      const timeNow = Math.round(Date.now() / 1000);\n\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n        this._saveSession(currentSession);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n      }\n    } catch (error) {\n      console.log('error', error);\n    }\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n        if (!data) return null;\n        const {\n          currentSession,\n          expiresAt\n        } = data;\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n\n              if (error.message === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return;\n              }\n\n              yield this._removeSession();\n            }\n\n            this.networkRetries = 0;\n          } else {\n            this._removeSession();\n          }\n        } else if (!currentSession) {\n          console.log('Current session is missing data.');\n\n          this._removeSession();\n        } else {\n          // should be handled on _recoverSession method already\n          // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    });\n  }\n\n  _callRefreshToken(refresh_token) {\n    var _a;\n\n    if (refresh_token === void 0) {\n      refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) throw error;\n        if (!data) throw Error('Invalid session data.');\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, this.currentSession));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    this.currentSession = session;\n    this.currentUser = session.user;\n    const expiresAt = session.expires_at;\n\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000);\n      const expiresIn = expiresAt - timeNow;\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n    } // Do we need any extra check before persist session\n    // access_token or user ?\n\n\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession);\n    }\n  }\n\n  _persistSession(currentSession) {\n    const data = {\n      currentSession,\n      expiresAt: currentSession.expires_at\n    };\n    setItemAsync(this.localStorage, STORAGE_KEY, data);\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentSession = null;\n      this.currentUser = null;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      removeItemAsync(this.localStorage, STORAGE_KEY);\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const {\n        error\n      } = yield this._callRefreshToken();\n      if (!error) this.networkRetries = 0;\n      if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n\n\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a;\n\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n\n          if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n            this._saveSession(newSession.currentSession);\n\n            this._notifyAllSubscribers('SIGNED_IN');\n          } else {\n            this._removeSession();\n\n            this._notifyAllSubscribers('SIGNED_OUT');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n    }\n  }\n\n  _handleVisibilityChange() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          this._recoverAndRefresh();\n        }\n      });\n    } catch (error) {\n      console.error('_handleVisibilityChange', error);\n    }\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","GoTrueApi","isBrowser","getParameterByName","uuid","setItemAsync","removeItemAsync","getItemSynchronously","getItemAsync","GOTRUE_URL","DEFAULT_HEADERS","STORAGE_KEY","EXPIRY_MARGIN","NETWORK_FAILURE","polyfillGlobalThis","DEFAULT_OPTIONS","url","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","GoTrueClient","constructor","options","stateChangeEmitters","Map","networkRetries","settings","Object","assign","currentUser","currentSession","localStorage","globalThis","api","cookieOptions","fetch","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","_handleVisibilityChange","getSessionFromUrl","storeSession","error","Error","signUp","email","password","phone","_removeSession","data","signUpWithPhone","captchaToken","signUpWithEmail","redirectTo","session","user","access_token","_saveSession","_notifyAllSubscribers","id","signIn","refreshToken","provider","oidc","sendMagicLinkEmail","shouldCreateUser","_handleEmailSignIn","sendMobileOTP","_handlePhoneSignIn","_callRefreshToken","_handleProviderSignIn","scopes","queryParams","_handleOpenIDConnectSignIn","verifyOTP","params","refreshSession","_a","update","attributes","updateUser","setSession","refresh_token","refreshAccessToken","setAuth","token_type","error_description","provider_token","provider_refresh_token","expires_in","timeNow","Math","round","Date","now","expires_at","parseInt","getUser","recoveryMode","window","location","hash","signOut","accessToken","onAuthStateChange","callback","subscription","unsubscribe","delete","set","_b","signInWithEmail","confirmed_at","email_confirmed_at","signInWithPhone","phone_confirmed_at","getUrlForProvider","href","id_token","nonce","client_id","issuer","signInWithOpenIDConnect","expiresAt","console","log","message","ERROR_MESSAGE","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","pow","RETRY_INTERVAL","err","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","unref","addEventListener","key","newSession","JSON","parse","String","newValue","document","visibilityState"],"sources":["C:/Users/Sergipetec/Documents/supabase-angular/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync, } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE, } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        this.networkRetries = 0;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new GoTrueApi({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch,\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        this._handleVisibilityChange();\n        if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n            // Handle the OAuth redirect\n            this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n                if (error) {\n                    throw new Error('Error getting session from URL.');\n                }\n            });\n        }\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n     * @param data Optional user metadata.\n     */\n    signUp({ email, password, phone }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = phone && password\n                    ? yield this.api.signUpWithPhone(phone, password, {\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    })\n                    : yield this.api.signUpWithEmail(email, password, {\n                        redirectTo: options.redirectTo,\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on sign up.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    signIn({ email, phone, password, refreshToken, provider, oidc }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (email && password) {\n                    return this._handleEmailSignIn(email, password, {\n                        redirectTo: options.redirectTo,\n                        captchaToken: options.captchaToken,\n                    });\n                }\n                if (phone && !password) {\n                    const { error } = yield this.api.sendMobileOTP(phone, {\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (phone && password) {\n                    return this._handlePhoneSignIn(phone, password);\n                }\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error } = yield this._callRefreshToken(refreshToken);\n                    if (error)\n                        throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null,\n                    };\n                }\n                if (provider) {\n                    return this._handleProviderSignIn(provider, {\n                        redirectTo: options.redirectTo,\n                        scopes: options.scopes,\n                        queryParams: options.queryParams,\n                    });\n                }\n                if (oidc) {\n                    return this._handleOpenIDConnectSignIn(oidc);\n                }\n                throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP(params, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = yield this.api.verifyOTP(params, options);\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n    user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n    session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n    refreshSession() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error } = yield this._callRefreshToken();\n                if (error)\n                    throw error;\n                return { data: this.currentSession, user: this.currentUser, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    update(attributes) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error)\n                    throw error;\n                if (!user)\n                    throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), { user });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return { data: user, user, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n    setSession(refresh_token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) {\n                    return { session: null, error: error };\n                }\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { session: data, error: null };\n            }\n            catch (e) {\n                return { error: e, session: null };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n    setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: this.user() });\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n    getSessionFromUrl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new Error('No browser detected.');\n                const error_description = getParameterByName('error_description');\n                if (error_description)\n                    throw new Error(error_description);\n                const provider_token = getParameterByName('provider_token');\n                const provider_refresh_token = getParameterByName('provider_refresh_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new Error('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new Error('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new Error('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user, error } = yield this.api.getUser(access_token);\n                if (error)\n                    throw error;\n                const session = {\n                    provider_token,\n                    provider_refresh_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user: user,\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = getParameterByName('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                    }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error } = yield this.api.signOut(accessToken);\n                if (error)\n                    return { error };\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n    onAuthStateChange(callback) {\n        try {\n            const id = uuid();\n            const subscription = {\n                id,\n                callback,\n                unsubscribe: () => {\n                    this.stateChangeEmitters.delete(id);\n                },\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return { data: subscription, error: null };\n        }\n        catch (e) {\n            return { data: null, error: e };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                    captchaToken: options.captchaToken,\n                });\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithPhone(phone, password, options);\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams,\n        });\n        try {\n            // try to open on the browser\n            if (isBrowser()) {\n                window.location.href = url;\n            }\n            return { provider, url, data: null, session: null, user: null, error: null };\n        }\n        catch (e) {\n            // fallback to returning the URL\n            if (url)\n                return { provider, url, data: null, session: null, user: null, error: null };\n            return { data: null, user: null, session: null, error: e };\n        }\n    }\n    _handleOpenIDConnectSignIn({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (id_token && nonce && ((client_id && issuer) || provider)) {\n                try {\n                    const { data, error } = yield this.api.signInWithOpenIDConnect({\n                        id_token,\n                        nonce,\n                        client_id,\n                        issuer,\n                        provider,\n                    });\n                    if (error || !data)\n                        return { user: null, session: null, error };\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    return { user: data.user, session: data, error: null };\n                }\n                catch (e) {\n                    return { user: null, session: null, error: e };\n                }\n            }\n            throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n        });\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n    _recoverSession() {\n        try {\n            const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n            if (!data)\n                return null;\n            const { currentSession, expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        }\n        catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n                if (!data)\n                    return null;\n                const { currentSession, expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        this.networkRetries++;\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            if (error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n                                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                                if (this.refreshTokenTimer)\n                                    clearTimeout(this.refreshTokenTimer);\n                                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                                );\n                                return;\n                            }\n                            yield this._removeSession();\n                        }\n                        this.networkRetries = 0;\n                    }\n                    else {\n                        this._removeSession();\n                    }\n                }\n                else if (!currentSession) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                }\n                else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error)\n                    throw error;\n                if (!data)\n                    throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) {\n            this._persistSession(this.currentSession);\n        }\n    }\n    _persistSession(currentSession) {\n        const data = { currentSession, expiresAt: currentSession.expires_at };\n        setItemAsync(this.localStorage, STORAGE_KEY, data);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer)\n                clearTimeout(this.refreshTokenTimer);\n            removeItemAsync(this.localStorage, STORAGE_KEY);\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            this.networkRetries++;\n            const { error } = yield this._callRefreshToken();\n            if (!error)\n                this.networkRetries = 0;\n            if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE &&\n                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n                this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n        }), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._saveSession(newSession.currentSession);\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    }\n                    else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n    _handleVisibilityChange() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'visible') {\n                    this._recoverAndRefresh();\n                }\n            });\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}