{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nexport default class RealtimeSubscription {\n  constructor(topic, params = {}, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.isLeaving() || this.isClosed()) {\n        return;\n      }\n\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return;\n      }\n\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n\n    if (this.socket.isConnected()) {\n      this.rejoin();\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      this.joinedOnce = true;\n      this.rejoin(timeout);\n      return this.joinPush;\n    }\n  }\n\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n\n  onError(callback) {\n    this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n  }\n\n  on(event, callback) {\n    this.bindings.push({\n      event,\n      callback\n    });\n  }\n\n  off(event) {\n    this.bindings = this.bindings.filter(bind => bind.event !== event);\n  }\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n\n  push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n\n    let pushEvent = new Push(this, event, payload, timeout);\n\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n\n\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n\n    let onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n    }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n    this.joinPush.destroy();\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n    leavePush.send();\n\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {});\n    }\n\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n\n\n  onMessage(event, payload, ref) {\n    return payload;\n  }\n\n  isMember(topic) {\n    return this.topic === topic;\n  }\n\n  joinRef() {\n    return this.joinPush.ref;\n  }\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n\n  trigger(event, payload, ref) {\n    let {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    let events = [close, error, leave, join];\n\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n      return;\n    }\n\n    let handledPayload = this.onMessage(event, payload, ref);\n\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n\n    this.bindings.filter(bind => {\n      // Bind all events if the user specifies a wildcard.\n      if (bind.event === '*') {\n        return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n      } else {\n        return bind.event === event;\n      }\n    }).map(bind => bind.callback(handledPayload, ref));\n  }\n\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n\n}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimeSubscription","constructor","topic","params","socket","bindings","state","closed","joinedOnce","pushBuffer","timeout","joinPush","join","rejoinTimer","rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","onClose","log","joinRef","remove","onError","reason","isLeaving","isClosed","errored","scheduleTimeout","isJoining","on","reply","payload","ref","trigger","replyEventName","isConnected","rejoin","subscribe","callback","close","error","event","push","off","filter","bind","canPush","isJoined","startTimeout","updateJoinPayload","updatePayload","unsubscribe","leaving","destroy","leavePush","leave","onMessage","isMember","leaveOpenTopic","joining","resend","events","indexOf","handledPayload","type","map","isErrored"],"sources":["C:/Users/Sergipetec/Documents/supabase-angular/node_modules/@supabase/realtime-js/dist/module/RealtimeSubscription.js"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nexport default class RealtimeSubscription {\n    constructor(topic, params = {}, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = [];\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this.onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket.remove(this);\n        });\n        this.onError((reason) => {\n            if (this.isLeaving() || this.isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this.isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n            this.trigger(this.replyEventName(ref), payload);\n        });\n    }\n    rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this.rejoin();\n        }\n    }\n    subscribe(timeout = this.timeout) {\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            this.joinedOnce = true;\n            this.rejoin(timeout);\n            return this.joinPush;\n        }\n    }\n    onClose(callback) {\n        this.on(CHANNEL_EVENTS.close, callback);\n    }\n    onError(callback) {\n        this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n    }\n    on(event, callback) {\n        this.bindings.push({ event, callback });\n    }\n    off(event) {\n        this.bindings = this.bindings.filter((bind) => bind.event !== event);\n    }\n    canPush() {\n        return this.socket.isConnected() && this.isJoined();\n    }\n    push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this.canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        let onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n        };\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n        leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n        leavePush.send();\n        if (!this.canPush()) {\n            leavePush.trigger('ok', {});\n        }\n        return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n    onMessage(event, payload, ref) {\n        return payload;\n    }\n    isMember(topic) {\n        return this.topic === topic;\n    }\n    joinRef() {\n        return this.joinPush.ref;\n    }\n    rejoin(timeout = this.timeout) {\n        if (this.isLeaving()) {\n            return;\n        }\n        this.socket.leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    trigger(event, payload, ref) {\n        let { close, error, leave, join } = CHANNEL_EVENTS;\n        let events = [close, error, leave, join];\n        if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n            return;\n        }\n        let handledPayload = this.onMessage(event, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        this.bindings\n            .filter((bind) => {\n            // Bind all events if the user specifies a wildcard.\n            if (bind.event === '*') {\n                return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n            }\n            else {\n                return bind.event === event;\n            }\n        })\n            .map((bind) => bind.callback(handledPayload, ref));\n    }\n    replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    isErrored() {\n        return this.state === CHANNEL_STATES.errored;\n    }\n    isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}