{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch\n  }) {\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n\n  cookieName() {\n    var _a;\n\n    return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(`${query}`);\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUpWithEmail(email, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n\n\n  signInWithEmail(email, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n\n\n  signUpWithPhone(phone, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n\n\n  signInWithPhone(phone, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n\n\n  signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=id_token';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n\n\n  sendMagicLinkEmail(email, options = {}) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n\n\n  sendMobileOTP(phone, options = {}) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyMobileOTP(phone, token, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP({\n    email,\n    phone,\n    token,\n    type = 'sms'\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          email,\n          phone,\n          token,\n          type,\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n\n\n  inviteUserByEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n\n\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n\n\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookies(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n\n    if (event === 'SIGNED_OUT') {\n      setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n\n    res.status(200).json({});\n  }\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n\n\n  deleteAuthCookie(req, res, {\n    redirectTo = '/'\n  }) {\n    setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n      name: `${this.cookieName()}-${key}`,\n      value: '',\n      maxAge: -1\n    })));\n    return res.redirect(307, redirectTo);\n  }\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n\n\n  getAuthCookieString(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      return getCookieString(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n\n    return res.getHeader('Set-Cookie');\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n\n\n  generateLink(type, email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  } // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n\n\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  getUserById(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n\n\n  getUserByCookie(req, res) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n\n        const access_token = req.cookies[`${this.cookieName()}-access-token`];\n        const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n\n        const {\n          user,\n          error: getUserError\n        } = yield this.getUser(access_token);\n\n        if (getUserError) {\n          if (!refresh_token) throw new Error('No refresh_token cookie found!');\n          if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n          const {\n            data,\n            error\n          } = yield this.refreshAccessToken(refresh_token);\n\n          if (error) {\n            throw error;\n          } else if (data) {\n            setCookies(req, res, [{\n              key: 'access-token',\n              value: data.access_token\n            }, {\n              key: 'refresh-token',\n              value: data.refresh_token\n            }].map(token => {\n              var _a;\n\n              return {\n                name: `${this.cookieName()}-${token.key}`,\n                value: token.value,\n                domain: this.cookieOptions.domain,\n                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                path: this.cookieOptions.path,\n                sameSite: this.cookieOptions.sameSite\n              };\n            }));\n            return {\n              token: data.access_token,\n              user: data.user,\n              data: data.user,\n              error: null\n            };\n          }\n        }\n\n        return {\n          token: access_token,\n          user: user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  updateUserById(uid, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this; //\n\n        const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n\n\n  deleteUser(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n\n\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n\n\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","get","post","put","remove","COOKIE_OPTIONS","setCookies","getCookieString","expiresAt","resolveFetch","GoTrueApi","constructor","url","headers","cookieOptions","fetch","Object","assign","_createRequestHeaders","jwt","cookieName","_a","name","getUrlForProvider","provider","options","urlParams","encodeURIComponent","redirectTo","push","scopes","queryParams","query","URLSearchParams","join","signUpWithEmail","email","password","queryString","data","gotrue_meta_security","captcha_token","captchaToken","session","expires_in","expires_at","error","signInWithEmail","signUpWithPhone","phone","signInWithPhone","signInWithOpenIDConnect","id_token","nonce","client_id","issuer","sendMagicLinkEmail","shouldCreateUser","create_user","sendMobileOTP","signOut","noResolveJson","verifyMobileOTP","token","type","redirect_to","verifyOTP","inviteUserByEmail","resetPasswordForEmail","refreshAccessToken","refreshToken","refresh_token","setAuthCookie","req","res","method","setHeader","status","end","event","body","Error","key","access_token","map","domain","maxAge","lifetime","path","sameSite","json","deleteAuthCookie","redirect","getAuthCookieString","getHeader","generateLink","createUser","attributes","user","listUsers","users","getUserById","uid","getUserByCookie","cookies","getUserError","getUser","updateUserById","deleteUser","updateUser"],"sources":["C:/Users/Sergipetec/Documents/supabase-angular/node_modules/@supabase/gotrue-js/dist/module/GoTrueApi.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n    constructor({ url = '', headers = {}, cookieOptions, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Create a temporary object with all configured headers and\n     * adds the Authorization token to be used on request methods\n     * @param jwt A valid, logged-in JWT.\n     */\n    _createRequestHeaders(jwt) {\n        const headers = Object.assign({}, this.headers);\n        headers['Authorization'] = `Bearer ${jwt}`;\n        return headers;\n    }\n    cookieName() {\n        var _a;\n        return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    getUrlForProvider(provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(`${query}`);\n        }\n        return `${this.url}/authorize?${urlParams.join('&')}`;\n    }\n    /**\n     * Creates a new user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    signUpWithEmail(email, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n                    email,\n                    password,\n                    data: options.data,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    signInWithEmail(email, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '?grant_type=password';\n                if (options.redirectTo) {\n                    queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { email, password, gotrue_meta_security: { captcha_token: options.captchaToken } }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Signs up a new user using their phone number and a password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param data Optional user metadata.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    signUpWithPhone(phone, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/signup`, {\n                    phone,\n                    password,\n                    data: options.data,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their phone number and password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    signInWithPhone(phone, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=password';\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { phone, password, gotrue_meta_security: { captcha_token: options.captchaToken } }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an OpenID Connect user using their id_token.\n     * @param id_token The IDToken of the user.\n     * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n     * @param provider The provider of the user.\n     * @param client_id The clientID of the user.\n     * @param issuer The issuer of the user.\n     */\n    signInWithOpenIDConnect({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=id_token';\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { id_token, nonce, client_id, issuer, provider }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a magic login link to an email address.\n     * @param email The email address of the user.\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    sendMagicLinkEmail(email, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n                    email,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n     * @param phone The user's phone number WITH international prefix\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    sendMobileOTP(phone, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/otp`, {\n                    phone,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     */\n    signOut(jwt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield post(this.fetch, `${this.url}/logout`, {}, { headers: this._createRequestHeaders(jwt), noResolveJson: true });\n                return { error: null };\n            }\n            catch (e) {\n                return { error: e };\n            }\n        });\n    }\n    /**\n     * @deprecated Use `verifyOTP` instead!\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyMobileOTP(phone, token, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/verify`, { phone, token, type: 'sms', redirect_to: options.redirectTo }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Send User supplied Email / Mobile OTP to be verified\n     * @param email The user's email address\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param type verification type that the otp is generated for\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP({ email, phone, token, type = 'sms' }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/verify`, { email, phone, token, type, redirect_to: options.redirectTo }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata\n     */\n    inviteUserByEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/invite${queryString}`, { email, data: options.data }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a reset request to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    resetPasswordForEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/recover${queryString}`, { email, gotrue_meta_security: { captcha_token: options.captchaToken } }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    refreshAccessToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, { refresh_token: refreshToken }, { headers: this.headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Set/delete the auth cookie based on the AuthChangeEvent.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     * @param req The request object.\n     * @param res The response object.\n     */\n    setAuthCookie(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event, session } = req.body;\n        if (!event)\n            throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session)\n                throw new Error('Auth session missing!');\n            setCookies(req, res, [\n                { key: 'access-token', value: session.access_token },\n                { key: 'refresh-token', value: session.refresh_token },\n            ].map((token) => {\n                var _a;\n                return ({\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite,\n                });\n            }));\n        }\n        if (event === 'SIGNED_OUT') {\n            setCookies(req, res, ['access-token', 'refresh-token'].map((key) => ({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1,\n            })));\n        }\n        res.status(200).json({});\n    }\n    /**\n     * Deletes the Auth Cookies and redirects to the\n     * @param req The request object.\n     * @param res The response object.\n     * @param options Optionally specify a `redirectTo` URL in the options.\n     */\n    deleteAuthCookie(req, res, { redirectTo = '/' }) {\n        setCookies(req, res, ['access-token', 'refresh-token'].map((key) => ({\n            name: `${this.cookieName()}-${key}`,\n            value: '',\n            maxAge: -1,\n        })));\n        return res.redirect(307, redirectTo);\n    }\n    /**\n     * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n     * @param req The request object.\n     * @param res The response object.\n     * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n     */\n    getAuthCookieString(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event, session } = req.body;\n        if (!event)\n            throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session)\n                throw new Error('Auth session missing!');\n            return getCookieString(req, res, [\n                { key: 'access-token', value: session.access_token },\n                { key: 'refresh-token', value: session.refresh_token },\n            ].map((token) => {\n                var _a;\n                return ({\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite,\n                });\n            }));\n        }\n        if (event === 'SIGNED_OUT') {\n            return getCookieString(req, res, ['access-token', 'refresh-token'].map((key) => ({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1,\n            })));\n        }\n        return res.getHeader('Set-Cookie');\n    }\n    /**\n     * Generates links to be sent via email or other.\n     * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     * @param email The user's email.\n     * @param password User password. For signup only.\n     * @param data Optional user metadata. For signup only.\n     * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     */\n    generateLink(type, email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n                    type,\n                    email,\n                    password: options.password,\n                    data: options.data,\n                    redirect_to: options.redirectTo,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param attributes The data you want to create the user with.\n     */\n    createUser(attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    listUsers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/admin/users`, {\n                    headers: this.headers,\n                });\n                return { data: data.users, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    getUserById(uid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n                    headers: this.headers,\n                });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get user by reading the cookie from the request.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     */\n    getUserByCookie(req, res) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!req.cookies) {\n                    throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n                }\n                const access_token = req.cookies[`${this.cookieName()}-access-token`];\n                const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n                if (!access_token) {\n                    throw new Error('No cookie found!');\n                }\n                const { user, error: getUserError } = yield this.getUser(access_token);\n                if (getUserError) {\n                    if (!refresh_token)\n                        throw new Error('No refresh_token cookie found!');\n                    if (!res)\n                        throw new Error('You need to pass the res object to automatically refresh the session!');\n                    const { data, error } = yield this.refreshAccessToken(refresh_token);\n                    if (error) {\n                        throw error;\n                    }\n                    else if (data) {\n                        setCookies(req, res, [\n                            { key: 'access-token', value: data.access_token },\n                            { key: 'refresh-token', value: data.refresh_token },\n                        ].map((token) => {\n                            var _a;\n                            return ({\n                                name: `${this.cookieName()}-${token.key}`,\n                                value: token.value,\n                                domain: this.cookieOptions.domain,\n                                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                                path: this.cookieOptions.path,\n                                sameSite: this.cookieOptions.sameSite,\n                            });\n                        }));\n                        return { token: data.access_token, user: data.user, data: data.user, error: null };\n                    }\n                }\n                return { token: access_token, user: user, data: user, error: null };\n            }\n            catch (e) {\n                return { token: null, user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    updateUserById(uid, attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this; //\n                const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param uid The user uid you want to remove.\n     */\n    deleteUser(uid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Gets the current user details.\n     *\n     * This method is called by the GoTrueClient `update` where\n     * the jwt is set to this.currentSession.access_token\n     * and therefore, acts like getting the currently authenticated user\n     *\n     * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n     */\n    getUser(jwt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/user`, {\n                    headers: this._createRequestHeaders(jwt),\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     * @param jwt A valid, logged-in JWT.\n     * @param attributes The data you want to update.\n     */\n    updateUser(jwt, attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n                    headers: this._createRequestHeaders(jwt),\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n}\n"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;EACrF,SAASC,KAAT,CAAeC,KAAf,EAAsB;IAAE,OAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;MAAEA,OAAO,CAACD,KAAD,CAAP;IAAiB,CAA5C,CAApC;EAAoF;;EAC5G,OAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;IACvD,SAASC,SAAT,CAAmBJ,KAAnB,EAA0B;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;MAA8B,CAApC,CAAqC,OAAOO,CAAP,EAAU;QAAEJ,MAAM,CAACI,CAAD,CAAN;MAAY;IAAE;;IAC3F,SAASC,QAAT,CAAkBR,KAAlB,EAAyB;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;MAAkC,CAAxC,CAAyC,OAAOO,CAAP,EAAU;QAAEJ,MAAM,CAACI,CAAD,CAAN;MAAY;IAAE;;IAC9F,SAASF,IAAT,CAAcI,MAAd,EAAsB;MAAEA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;IAAsF;;IAC9GH,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;EACH,CALM,CAAP;AAMH,CARD;;AASA,SAASO,GAAT,EAAcC,IAAd,EAAoBC,GAApB,EAAyBC,MAAzB,QAAuC,aAAvC;AACA,SAASC,cAAT,QAA+B,iBAA/B;AACA,SAASC,UAAT,EAAqBC,eAArB,QAA4C,eAA5C;AACA,SAASC,SAAT,EAAoBC,YAApB,QAAwC,eAAxC;AACA,eAAe,MAAMC,SAAN,CAAgB;EAC3BC,WAAW,CAAC;IAAEC,GAAG,GAAG,EAAR;IAAYC,OAAO,GAAG,EAAtB;IAA0BC,aAA1B;IAAyCC;EAAzC,CAAD,EAAoD;IAC3D,KAAKH,GAAL,GAAWA,GAAX;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,aAAL,GAAqBE,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBZ,cAAlB,CAAd,EAAiDS,aAAjD,CAArB;IACA,KAAKC,KAAL,GAAaN,YAAY,CAACM,KAAD,CAAzB;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIG,qBAAqB,CAACC,GAAD,EAAM;IACvB,MAAMN,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;IACAA,OAAO,CAAC,eAAD,CAAP,GAA4B,UAASM,GAAI,EAAzC;IACA,OAAON,OAAP;EACH;;EACDO,UAAU,GAAG;IACT,IAAIC,EAAJ;;IACA,OAAO,CAACA,EAAE,GAAG,KAAKP,aAAL,CAAmBQ,IAAzB,MAAmC,IAAnC,IAA2CD,EAAE,KAAK,KAAK,CAAvD,GAA2DA,EAA3D,GAAgE,EAAvE;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIE,iBAAiB,CAACC,QAAD,EAAWC,OAAX,EAAoB;IACjC,MAAMC,SAAS,GAAG,CAAE,YAAWC,kBAAkB,CAACH,QAAD,CAAW,EAA1C,CAAlB;;IACA,IAAIC,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACG,UAA9D,EAA0E;MACtEF,SAAS,CAACG,IAAV,CAAgB,eAAcF,kBAAkB,CAACF,OAAO,CAACG,UAAT,CAAqB,EAArE;IACH;;IACD,IAAIH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACK,MAA9D,EAAsE;MAClEJ,SAAS,CAACG,IAAV,CAAgB,UAASF,kBAAkB,CAACF,OAAO,CAACK,MAAT,CAAiB,EAA5D;IACH;;IACD,IAAIL,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACM,WAA9D,EAA2E;MACvE,MAAMC,KAAK,GAAG,IAAIC,eAAJ,CAAoBR,OAAO,CAACM,WAA5B,CAAd;MACAL,SAAS,CAACG,IAAV,CAAgB,GAAEG,KAAM,EAAxB;IACH;;IACD,OAAQ,GAAE,KAAKpB,GAAI,cAAac,SAAS,CAACQ,IAAV,CAAe,GAAf,CAAoB,EAApD;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,eAAe,CAACC,KAAD,EAAQC,QAAR,EAAkBZ,OAAO,GAAG,EAA5B,EAAgC;IAC3C,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,IAAIyB,WAAW,GAAG,EAAlB;;QACA,IAAIb,OAAO,CAACG,UAAZ,EAAwB;UACpBU,WAAW,GAAG,kBAAkBX,kBAAkB,CAACF,OAAO,CAACG,UAAT,CAAlD;QACH;;QACD,MAAMW,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,UAAS0B,WAAY,EAA9C,EAAiD;UACpEF,KADoE;UAEpEC,QAFoE;UAGpEE,IAAI,EAAEd,OAAO,CAACc,IAHsD;UAIpEC,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAJ8C,CAAjD,EAKpB;UAAE7B;QAAF,CALoB,CAAvB;QAMA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CAhBD,CAiBA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CArBe,CAAhB;EAsBH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIoD,eAAe,CAACX,KAAD,EAAQC,QAAR,EAAkBZ,OAAO,GAAG,EAA5B,EAAgC;IAC3C,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,IAAIyB,WAAW,GAAG,sBAAlB;;QACA,IAAIb,OAAO,CAACG,UAAZ,EAAwB;UACpBU,WAAW,IAAI,kBAAkBX,kBAAkB,CAACF,OAAO,CAACG,UAAT,CAAnD;QACH;;QACD,MAAMW,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAQ0B,WAAY,EAA7C,EAAgD;UAAEF,KAAF;UAASC,QAAT;UAAmBG,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAAzC,CAAhD,EAAoI;UAAE7B;QAAF,CAApI,CAAvB;QACA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CAXD,CAYA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAhBe,CAAhB;EAiBH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIqD,eAAe,CAACC,KAAD,EAAQZ,QAAR,EAAkBZ,OAAO,GAAG,EAA5B,EAAgC;IAC3C,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,MAAM0B,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAzB,EAAmC;UACtDqC,KADsD;UAEtDZ,QAFsD;UAGtDE,IAAI,EAAEd,OAAO,CAACc,IAHwC;UAItDC,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAJgC,CAAnC,EAKpB;UAAE7B;QAAF,CALoB,CAAvB;QAMA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CAZD,CAaA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAjBe,CAAhB;EAkBH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIuD,eAAe,CAACD,KAAD,EAAQZ,QAAR,EAAkBZ,OAAO,GAAG,EAA5B,EAAgC;IAC3C,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,MAAMyB,WAAW,GAAG,sBAApB;QACA,MAAMC,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAQ0B,WAAY,EAA7C,EAAgD;UAAEW,KAAF;UAASZ,QAAT;UAAmBG,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAAzC,CAAhD,EAAoI;UAAE7B;QAAF,CAApI,CAAvB;QACA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CARD,CASA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAbe,CAAhB;EAcH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIwD,uBAAuB,CAAC;IAAEC,QAAF;IAAYC,KAAZ;IAAmBC,SAAnB;IAA8BC,MAA9B;IAAsC/B;EAAtC,CAAD,EAAoD;IACvE,OAAO1C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,MAAMyB,WAAW,GAAG,sBAApB;QACA,MAAMC,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAQ0B,WAAY,EAA7C,EAAgD;UAAEc,QAAF;UAAYC,KAAZ;UAAmBC,SAAnB;UAA8BC,MAA9B;UAAsC/B;QAAtC,CAAhD,EAAkG;UAAEX;QAAF,CAAlG,CAAvB;QACA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CARD,CASA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAbe,CAAhB;EAcH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACI6D,kBAAkB,CAACpB,KAAD,EAAQX,OAAO,GAAG,EAAlB,EAAsB;IACpC,IAAIJ,EAAJ;;IACA,OAAOvC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,IAAIyB,WAAW,GAAG,EAAlB;;QACA,IAAIb,OAAO,CAACG,UAAZ,EAAwB;UACpBU,WAAW,IAAI,kBAAkBX,kBAAkB,CAACF,OAAO,CAACG,UAAT,CAAnD;QACH;;QACD,MAAM6B,gBAAgB,GAAG,CAACpC,EAAE,GAAGI,OAAO,CAACgC,gBAAd,MAAoC,IAApC,IAA4CpC,EAAE,KAAK,KAAK,CAAxD,GAA4DA,EAA5D,GAAiE,IAA1F;QACA,MAAMkB,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,OAAM0B,WAAY,EAA3C,EAA8C;UACjEF,KADiE;UAEjEsB,WAAW,EAAED,gBAFoD;UAGjEjB,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAH2C,CAA9C,EAIpB;UAAE7B;QAAF,CAJoB,CAAvB;QAKA,OAAO;UAAE0B,IAAF;UAAQO,KAAK,EAAE;QAAf,CAAP;MACH,CAbD,CAcA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAlBe,CAAhB;EAmBH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIgE,aAAa,CAACV,KAAD,EAAQxB,OAAO,GAAG,EAAlB,EAAsB;IAC/B,IAAIJ,EAAJ;;IACA,OAAOvC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM2E,gBAAgB,GAAG,CAACpC,EAAE,GAAGI,OAAO,CAACgC,gBAAd,MAAoC,IAApC,IAA4CpC,EAAE,KAAK,KAAK,CAAxD,GAA4DA,EAA5D,GAAiE,IAA1F;QACA,MAAMR,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,MAAM0B,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,MAAzB,EAAgC;UACnDqC,KADmD;UAEnDS,WAAW,EAAED,gBAFsC;UAGnDjB,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAH6B,CAAhC,EAIpB;UAAE7B;QAAF,CAJoB,CAAvB;QAKA,OAAO;UAAE0B,IAAF;UAAQO,KAAK,EAAE;QAAf,CAAP;MACH,CATD,CAUA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAde,CAAhB;EAeH;EACD;AACJ;AACA;AACA;;;EACIiE,OAAO,CAACzC,GAAD,EAAM;IACT,OAAOrC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMoB,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAzB,EAAmC,EAAnC,EAAuC;UAAEC,OAAO,EAAE,KAAKK,qBAAL,CAA2BC,GAA3B,CAAX;UAA4C0C,aAAa,EAAE;QAA3D,CAAvC,CAAV;QACA,OAAO;UAAEf,KAAK,EAAE;QAAT,CAAP;MACH,CAHD,CAIA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEmD,KAAK,EAAEnD;QAAT,CAAP;MACH;IACJ,CARe,CAAhB;EASH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACImE,eAAe,CAACb,KAAD,EAAQc,KAAR,EAAetC,OAAO,GAAG,EAAzB,EAA6B;IACxC,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,MAAM0B,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAzB,EAAmC;UAAEqC,KAAF;UAASc,KAAT;UAAgBC,IAAI,EAAE,KAAtB;UAA6BC,WAAW,EAAExC,OAAO,CAACG;QAAlD,CAAnC,EAAmG;UAAEf;QAAF,CAAnG,CAAvB;QACA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CAPD,CAQA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAZe,CAAhB;EAaH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIuE,SAAS,CAAC;IAAE9B,KAAF;IAASa,KAAT;IAAgBc,KAAhB;IAAuBC,IAAI,GAAG;EAA9B,CAAD,EAAwCvC,OAAO,GAAG,EAAlD,EAAsD;IAC3D,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,MAAM0B,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,SAAzB,EAAmC;UAAEwB,KAAF;UAASa,KAAT;UAAgBc,KAAhB;UAAuBC,IAAvB;UAA6BC,WAAW,EAAExC,OAAO,CAACG;QAAlD,CAAnC,EAAmG;UAAEf;QAAF,CAAnG,CAAvB;QACA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CAPD,CAQA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAZe,CAAhB;EAaH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIwE,iBAAiB,CAAC/B,KAAD,EAAQX,OAAO,GAAG,EAAlB,EAAsB;IACnC,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,IAAIyB,WAAW,GAAG,EAAlB;;QACA,IAAIb,OAAO,CAACG,UAAZ,EAAwB;UACpBU,WAAW,IAAI,kBAAkBX,kBAAkB,CAACF,OAAO,CAACG,UAAT,CAAnD;QACH;;QACD,MAAMW,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,UAAS0B,WAAY,EAA9C,EAAiD;UAAEF,KAAF;UAASG,IAAI,EAAEd,OAAO,CAACc;QAAvB,CAAjD,EAAgF;UAAE1B;QAAF,CAAhF,CAAvB;QACA,OAAO;UAAE0B,IAAF;UAAQO,KAAK,EAAE;QAAf,CAAP;MACH,CARD,CASA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAbe,CAAhB;EAcH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIyE,qBAAqB,CAAChC,KAAD,EAAQX,OAAO,GAAG,EAAlB,EAAsB;IACvC,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAM+B,OAAO,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKJ,OAAvB,CAAhB;QACA,IAAIyB,WAAW,GAAG,EAAlB;;QACA,IAAIb,OAAO,CAACG,UAAZ,EAAwB;UACpBU,WAAW,IAAI,kBAAkBX,kBAAkB,CAACF,OAAO,CAACG,UAAT,CAAnD;QACH;;QACD,MAAMW,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,WAAU0B,WAAY,EAA/C,EAAkD;UAAEF,KAAF;UAASI,oBAAoB,EAAE;YAAEC,aAAa,EAAEhB,OAAO,CAACiB;UAAzB;QAA/B,CAAlD,EAA4H;UAAE7B;QAAF,CAA5H,CAAvB;QACA,OAAO;UAAE0B,IAAF;UAAQO,KAAK,EAAE;QAAf,CAAP;MACH,CARD,CASA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAbe,CAAhB;EAcH;EACD;AACJ;AACA;AACA;;;EACI0E,kBAAkB,CAACC,YAAD,EAAe;IAC7B,OAAOxF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,iCAAzB,EAA2D;UAAE2D,aAAa,EAAED;QAAjB,CAA3D,EAA4F;UAAEzD,OAAO,EAAE,KAAKA;QAAhB,CAA5F,CAAvB;QACA,MAAM8B,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsB,IAAlB,CAAhB;QACA,IAAII,OAAO,CAACC,UAAZ,EACID,OAAO,CAACE,UAAR,GAAqBrC,SAAS,CAAC+B,IAAI,CAACK,UAAN,CAA9B;QACJ,OAAO;UAAEL,IAAI,EAAEI,OAAR;UAAiBG,KAAK,EAAE;QAAxB,CAAP;MACH,CAND,CAOA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAXe,CAAhB;EAYH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACI6E,aAAa,CAACC,GAAD,EAAMC,GAAN,EAAW;IACpB,IAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;MACvBD,GAAG,CAACE,SAAJ,CAAc,OAAd,EAAuB,MAAvB;MACAF,GAAG,CAACG,MAAJ,CAAW,GAAX,EAAgBC,GAAhB,CAAoB,oBAApB;IACH;;IACD,MAAM;MAAEC,KAAF;MAASpC;IAAT,IAAqB8B,GAAG,CAACO,IAA/B;IACA,IAAI,CAACD,KAAL,EACI,MAAM,IAAIE,KAAJ,CAAU,qBAAV,CAAN;;IACJ,IAAIF,KAAK,KAAK,WAAd,EAA2B;MACvB,IAAI,CAACpC,OAAL,EACI,MAAM,IAAIsC,KAAJ,CAAU,uBAAV,CAAN;MACJ3E,UAAU,CAACmE,GAAD,EAAMC,GAAN,EAAW,CACjB;QAAEQ,GAAG,EAAE,cAAP;QAAuB9F,KAAK,EAAEuD,OAAO,CAACwC;MAAtC,CADiB,EAEjB;QAAED,GAAG,EAAE,eAAP;QAAwB9F,KAAK,EAAEuD,OAAO,CAAC4B;MAAvC,CAFiB,EAGnBa,GAHmB,CAGdrB,KAAD,IAAW;QACb,IAAI1C,EAAJ;;QACA,OAAQ;UACJC,IAAI,EAAG,GAAE,KAAKF,UAAL,EAAkB,IAAG2C,KAAK,CAACmB,GAAI,EADpC;UAEJ9F,KAAK,EAAE2E,KAAK,CAAC3E,KAFT;UAGJiG,MAAM,EAAE,KAAKvE,aAAL,CAAmBuE,MAHvB;UAIJC,MAAM,EAAE,CAACjE,EAAE,GAAG,KAAKP,aAAL,CAAmByE,QAAzB,MAAuC,IAAvC,IAA+ClE,EAAE,KAAK,KAAK,CAA3D,GAA+DA,EAA/D,GAAoE,CAJxE;UAKJmE,IAAI,EAAE,KAAK1E,aAAL,CAAmB0E,IALrB;UAMJC,QAAQ,EAAE,KAAK3E,aAAL,CAAmB2E;QANzB,CAAR;MAQH,CAboB,CAAX,CAAV;IAcH;;IACD,IAAIV,KAAK,KAAK,YAAd,EAA4B;MACxBzE,UAAU,CAACmE,GAAD,EAAMC,GAAN,EAAW,CAAC,cAAD,EAAiB,eAAjB,EAAkCU,GAAlC,CAAuCF,GAAD,KAAU;QACjE5D,IAAI,EAAG,GAAE,KAAKF,UAAL,EAAkB,IAAG8D,GAAI,EAD+B;QAEjE9F,KAAK,EAAE,EAF0D;QAGjEkG,MAAM,EAAE,CAAC;MAHwD,CAAV,CAAtC,CAAX,CAAV;IAKH;;IACDZ,GAAG,CAACG,MAAJ,CAAW,GAAX,EAAgBa,IAAhB,CAAqB,EAArB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIC,gBAAgB,CAAClB,GAAD,EAAMC,GAAN,EAAW;IAAE9C,UAAU,GAAG;EAAf,CAAX,EAAiC;IAC7CtB,UAAU,CAACmE,GAAD,EAAMC,GAAN,EAAW,CAAC,cAAD,EAAiB,eAAjB,EAAkCU,GAAlC,CAAuCF,GAAD,KAAU;MACjE5D,IAAI,EAAG,GAAE,KAAKF,UAAL,EAAkB,IAAG8D,GAAI,EAD+B;MAEjE9F,KAAK,EAAE,EAF0D;MAGjEkG,MAAM,EAAE,CAAC;IAHwD,CAAV,CAAtC,CAAX,CAAV;IAKA,OAAOZ,GAAG,CAACkB,QAAJ,CAAa,GAAb,EAAkBhE,UAAlB,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIiE,mBAAmB,CAACpB,GAAD,EAAMC,GAAN,EAAW;IAC1B,IAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;MACvBD,GAAG,CAACE,SAAJ,CAAc,OAAd,EAAuB,MAAvB;MACAF,GAAG,CAACG,MAAJ,CAAW,GAAX,EAAgBC,GAAhB,CAAoB,oBAApB;IACH;;IACD,MAAM;MAAEC,KAAF;MAASpC;IAAT,IAAqB8B,GAAG,CAACO,IAA/B;IACA,IAAI,CAACD,KAAL,EACI,MAAM,IAAIE,KAAJ,CAAU,qBAAV,CAAN;;IACJ,IAAIF,KAAK,KAAK,WAAd,EAA2B;MACvB,IAAI,CAACpC,OAAL,EACI,MAAM,IAAIsC,KAAJ,CAAU,uBAAV,CAAN;MACJ,OAAO1E,eAAe,CAACkE,GAAD,EAAMC,GAAN,EAAW,CAC7B;QAAEQ,GAAG,EAAE,cAAP;QAAuB9F,KAAK,EAAEuD,OAAO,CAACwC;MAAtC,CAD6B,EAE7B;QAAED,GAAG,EAAE,eAAP;QAAwB9F,KAAK,EAAEuD,OAAO,CAAC4B;MAAvC,CAF6B,EAG/Ba,GAH+B,CAG1BrB,KAAD,IAAW;QACb,IAAI1C,EAAJ;;QACA,OAAQ;UACJC,IAAI,EAAG,GAAE,KAAKF,UAAL,EAAkB,IAAG2C,KAAK,CAACmB,GAAI,EADpC;UAEJ9F,KAAK,EAAE2E,KAAK,CAAC3E,KAFT;UAGJiG,MAAM,EAAE,KAAKvE,aAAL,CAAmBuE,MAHvB;UAIJC,MAAM,EAAE,CAACjE,EAAE,GAAG,KAAKP,aAAL,CAAmByE,QAAzB,MAAuC,IAAvC,IAA+ClE,EAAE,KAAK,KAAK,CAA3D,GAA+DA,EAA/D,GAAoE,CAJxE;UAKJmE,IAAI,EAAE,KAAK1E,aAAL,CAAmB0E,IALrB;UAMJC,QAAQ,EAAE,KAAK3E,aAAL,CAAmB2E;QANzB,CAAR;MAQH,CAbgC,CAAX,CAAtB;IAcH;;IACD,IAAIV,KAAK,KAAK,YAAd,EAA4B;MACxB,OAAOxE,eAAe,CAACkE,GAAD,EAAMC,GAAN,EAAW,CAAC,cAAD,EAAiB,eAAjB,EAAkCU,GAAlC,CAAuCF,GAAD,KAAU;QAC7E5D,IAAI,EAAG,GAAE,KAAKF,UAAL,EAAkB,IAAG8D,GAAI,EAD2C;QAE7E9F,KAAK,EAAE,EAFsE;QAG7EkG,MAAM,EAAE,CAAC;MAHoE,CAAV,CAAtC,CAAX,CAAtB;IAKH;;IACD,OAAOZ,GAAG,CAACoB,SAAJ,CAAc,YAAd,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,YAAY,CAAC/B,IAAD,EAAO5B,KAAP,EAAcX,OAAO,GAAG,EAAxB,EAA4B;IACpC,OAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,sBAAzB,EAAgD;UACnEoD,IADmE;UAEnE5B,KAFmE;UAGnEC,QAAQ,EAAEZ,OAAO,CAACY,QAHiD;UAInEE,IAAI,EAAEd,OAAO,CAACc,IAJqD;UAKnE0B,WAAW,EAAExC,OAAO,CAACG;QAL8C,CAAhD,EAMpB;UAAEf,OAAO,EAAE,KAAKA;QAAhB,CANoB,CAAvB;QAOA,OAAO;UAAE0B,IAAF;UAAQO,KAAK,EAAE;QAAf,CAAP;MACH,CATD,CAUA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAde,CAAhB;EAeH,CArd0B,CAsd3B;;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIqG,UAAU,CAACC,UAAD,EAAa;IACnB,OAAOnH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMrC,IAAI,CAAC,KAAKa,KAAN,EAAc,GAAE,KAAKH,GAAI,cAAzB,EAAwCqF,UAAxC,EAAoD;UACvEpF,OAAO,EAAE,KAAKA;QADyD,CAApD,CAAvB;QAGA,OAAO;UAAEqF,IAAI,EAAE3D,IAAR;UAAcA,IAAd;UAAoBO,KAAK,EAAE;QAA3B,CAAP;MACH,CALD,CAMA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEuG,IAAI,EAAE,IAAR;UAAc3D,IAAI,EAAE,IAApB;UAA0BO,KAAK,EAAEnD;QAAjC,CAAP;MACH;IACJ,CAVe,CAAhB;EAWH;EACD;AACJ;AACA;AACA;AACA;;;EACIwG,SAAS,GAAG;IACR,OAAOrH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMtC,GAAG,CAAC,KAAKc,KAAN,EAAc,GAAE,KAAKH,GAAI,cAAzB,EAAwC;UAC1DC,OAAO,EAAE,KAAKA;QAD4C,CAAxC,CAAtB;QAGA,OAAO;UAAE0B,IAAI,EAAEA,IAAI,CAAC6D,KAAb;UAAoBtD,KAAK,EAAE;QAA3B,CAAP;MACH,CALD,CAMA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAVe,CAAhB;EAWH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACI0G,WAAW,CAACC,GAAD,EAAM;IACb,OAAOxH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMtC,GAAG,CAAC,KAAKc,KAAN,EAAc,GAAE,KAAKH,GAAI,gBAAe0F,GAAI,EAA5C,EAA+C;UACjEzF,OAAO,EAAE,KAAKA;QADmD,CAA/C,CAAtB;QAGA,OAAO;UAAE0B,IAAF;UAAQO,KAAK,EAAE;QAAf,CAAP;MACH,CALD,CAMA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAE4C,IAAI,EAAE,IAAR;UAAcO,KAAK,EAAEnD;QAArB,CAAP;MACH;IACJ,CAVe,CAAhB;EAWH;EACD;AACJ;AACA;AACA;;;EACI4G,eAAe,CAAC9B,GAAD,EAAMC,GAAN,EAAW;IACtB,OAAO5F,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,IAAI,CAAC2F,GAAG,CAAC+B,OAAT,EAAkB;UACd,MAAM,IAAIvB,KAAJ,CAAU,iGAAV,CAAN;QACH;;QACD,MAAME,YAAY,GAAGV,GAAG,CAAC+B,OAAJ,CAAa,GAAE,KAAKpF,UAAL,EAAkB,eAAjC,CAArB;QACA,MAAMmD,aAAa,GAAGE,GAAG,CAAC+B,OAAJ,CAAa,GAAE,KAAKpF,UAAL,EAAkB,gBAAjC,CAAtB;;QACA,IAAI,CAAC+D,YAAL,EAAmB;UACf,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;QACH;;QACD,MAAM;UAAEiB,IAAF;UAAQpD,KAAK,EAAE2D;QAAf,IAAgC,MAAM,KAAKC,OAAL,CAAavB,YAAb,CAA5C;;QACA,IAAIsB,YAAJ,EAAkB;UACd,IAAI,CAAClC,aAAL,EACI,MAAM,IAAIU,KAAJ,CAAU,gCAAV,CAAN;UACJ,IAAI,CAACP,GAAL,EACI,MAAM,IAAIO,KAAJ,CAAU,uEAAV,CAAN;UACJ,MAAM;YAAE1C,IAAF;YAAQO;UAAR,IAAkB,MAAM,KAAKuB,kBAAL,CAAwBE,aAAxB,CAA9B;;UACA,IAAIzB,KAAJ,EAAW;YACP,MAAMA,KAAN;UACH,CAFD,MAGK,IAAIP,IAAJ,EAAU;YACXjC,UAAU,CAACmE,GAAD,EAAMC,GAAN,EAAW,CACjB;cAAEQ,GAAG,EAAE,cAAP;cAAuB9F,KAAK,EAAEmD,IAAI,CAAC4C;YAAnC,CADiB,EAEjB;cAAED,GAAG,EAAE,eAAP;cAAwB9F,KAAK,EAAEmD,IAAI,CAACgC;YAApC,CAFiB,EAGnBa,GAHmB,CAGdrB,KAAD,IAAW;cACb,IAAI1C,EAAJ;;cACA,OAAQ;gBACJC,IAAI,EAAG,GAAE,KAAKF,UAAL,EAAkB,IAAG2C,KAAK,CAACmB,GAAI,EADpC;gBAEJ9F,KAAK,EAAE2E,KAAK,CAAC3E,KAFT;gBAGJiG,MAAM,EAAE,KAAKvE,aAAL,CAAmBuE,MAHvB;gBAIJC,MAAM,EAAE,CAACjE,EAAE,GAAG,KAAKP,aAAL,CAAmByE,QAAzB,MAAuC,IAAvC,IAA+ClE,EAAE,KAAK,KAAK,CAA3D,GAA+DA,EAA/D,GAAoE,CAJxE;gBAKJmE,IAAI,EAAE,KAAK1E,aAAL,CAAmB0E,IALrB;gBAMJC,QAAQ,EAAE,KAAK3E,aAAL,CAAmB2E;cANzB,CAAR;YAQH,CAboB,CAAX,CAAV;YAcA,OAAO;cAAE1B,KAAK,EAAExB,IAAI,CAAC4C,YAAd;cAA4Be,IAAI,EAAE3D,IAAI,CAAC2D,IAAvC;cAA6C3D,IAAI,EAAEA,IAAI,CAAC2D,IAAxD;cAA8DpD,KAAK,EAAE;YAArE,CAAP;UACH;QACJ;;QACD,OAAO;UAAEiB,KAAK,EAAEoB,YAAT;UAAuBe,IAAI,EAAEA,IAA7B;UAAmC3D,IAAI,EAAE2D,IAAzC;UAA+CpD,KAAK,EAAE;QAAtD,CAAP;MACH,CAtCD,CAuCA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEoE,KAAK,EAAE,IAAT;UAAemC,IAAI,EAAE,IAArB;UAA2B3D,IAAI,EAAE,IAAjC;UAAuCO,KAAK,EAAEnD;QAA9C,CAAP;MACH;IACJ,CA3Ce,CAAhB;EA4CH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIgH,cAAc,CAACL,GAAD,EAAML,UAAN,EAAkB;IAC5B,OAAOnH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,KADA,CACM;;QACN,MAAMyD,IAAI,GAAG,MAAMpC,GAAG,CAAC,KAAKY,KAAN,EAAc,GAAE,KAAKH,GAAI,gBAAe0F,GAAI,EAA5C,EAA+CL,UAA/C,EAA2D;UAC7EpF,OAAO,EAAE,KAAKA;QAD+D,CAA3D,CAAtB;QAGA,OAAO;UAAEqF,IAAI,EAAE3D,IAAR;UAAcA,IAAd;UAAoBO,KAAK,EAAE;QAA3B,CAAP;MACH,CAND,CAOA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEuG,IAAI,EAAE,IAAR;UAAc3D,IAAI,EAAE,IAApB;UAA0BO,KAAK,EAAEnD;QAAjC,CAAP;MACH;IACJ,CAXe,CAAhB;EAYH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIiH,UAAU,CAACN,GAAD,EAAM;IACZ,OAAOxH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMnC,MAAM,CAAC,KAAKW,KAAN,EAAc,GAAE,KAAKH,GAAI,gBAAe0F,GAAI,EAA5C,EAA+C,EAA/C,EAAmD;UACxEzF,OAAO,EAAE,KAAKA;QAD0D,CAAnD,CAAzB;QAGA,OAAO;UAAEqF,IAAI,EAAE3D,IAAR;UAAcA,IAAd;UAAoBO,KAAK,EAAE;QAA3B,CAAP;MACH,CALD,CAMA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEuG,IAAI,EAAE,IAAR;UAAc3D,IAAI,EAAE,IAApB;UAA0BO,KAAK,EAAEnD;QAAjC,CAAP;MACH;IACJ,CAVe,CAAhB;EAWH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI+G,OAAO,CAACvF,GAAD,EAAM;IACT,OAAOrC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMtC,GAAG,CAAC,KAAKc,KAAN,EAAc,GAAE,KAAKH,GAAI,OAAzB,EAAiC;UACnDC,OAAO,EAAE,KAAKK,qBAAL,CAA2BC,GAA3B;QAD0C,CAAjC,CAAtB;QAGA,OAAO;UAAE+E,IAAI,EAAE3D,IAAR;UAAcA,IAAd;UAAoBO,KAAK,EAAE;QAA3B,CAAP;MACH,CALD,CAMA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEuG,IAAI,EAAE,IAAR;UAAc3D,IAAI,EAAE,IAApB;UAA0BO,KAAK,EAAEnD;QAAjC,CAAP;MACH;IACJ,CAVe,CAAhB;EAWH;EACD;AACJ;AACA;AACA;AACA;;;EACIkH,UAAU,CAAC1F,GAAD,EAAM8E,UAAN,EAAkB;IACxB,OAAOnH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;MAChD,IAAI;QACA,MAAMyD,IAAI,GAAG,MAAMpC,GAAG,CAAC,KAAKY,KAAN,EAAc,GAAE,KAAKH,GAAI,OAAzB,EAAiCqF,UAAjC,EAA6C;UAC/DpF,OAAO,EAAE,KAAKK,qBAAL,CAA2BC,GAA3B;QADsD,CAA7C,CAAtB;QAGA,OAAO;UAAE+E,IAAI,EAAE3D,IAAR;UAAcA,IAAd;UAAoBO,KAAK,EAAE;QAA3B,CAAP;MACH,CALD,CAMA,OAAOnD,CAAP,EAAU;QACN,OAAO;UAAEuG,IAAI,EAAE,IAAR;UAAc3D,IAAI,EAAE,IAApB;UAA0BO,KAAK,EAAEnD;QAAjC,CAAP;MACH;IACJ,CAVe,CAAhB;EAWH;;AAnpB0B"},"metadata":{},"sourceType":"module"}