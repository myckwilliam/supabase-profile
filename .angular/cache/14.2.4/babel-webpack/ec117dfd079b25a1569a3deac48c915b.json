{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { resolveFetch } from './helper';\nexport class FunctionsClient {\n  constructor(url, {\n    headers = {},\n    customFetch\n  } = {}) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch(customFetch);\n  }\n  /**\n   * Updates the authorization header\n   * @params token - the new jwt token sent in the authorisation header\n   */\n\n\n  setAuth(token) {\n    this.headers.Authorization = `Bearer ${token}`;\n  }\n  /**\n   * Invokes a function\n   * @param functionName - the name of the function to invoke\n   * @param invokeOptions - object with the following properties\n   * `headers`: object representing the headers to send with the request\n   * `body`: the body of the request\n   * `responseType`: how the response should be parsed. The default is `json`\n   */\n\n\n  invoke(functionName, invokeOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          headers,\n          body\n        } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n        const response = yield this.fetch(`${this.url}/${functionName}`, {\n          method: 'POST',\n          headers: Object.assign({}, this.headers, headers),\n          body\n        });\n        const isRelayError = response.headers.get('x-relay-error');\n\n        if (isRelayError && isRelayError === 'true') {\n          return {\n            data: null,\n            error: new Error(yield response.text())\n          };\n        }\n\n        let data;\n        const {\n          responseType\n        } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n\n        if (!responseType || responseType === 'json') {\n          data = yield response.json();\n        } else if (responseType === 'arrayBuffer') {\n          data = yield response.arrayBuffer();\n        } else if (responseType === 'blob') {\n          data = yield response.blob();\n        } else {\n          data = yield response.text();\n        }\n\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        return {\n          data: null,\n          error\n        };\n      }\n    });\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","resolveFetch","FunctionsClient","constructor","url","headers","customFetch","fetch","setAuth","token","Authorization","invoke","functionName","invokeOptions","body","response","method","Object","assign","isRelayError","get","data","error","Error","text","responseType","json","arrayBuffer","blob"],"sources":["C:/Users/Sergipetec/Documents/supabase-angular/node_modules/@supabase/functions-js/dist/module/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { resolveFetch } from './helper';\nexport class FunctionsClient {\n    constructor(url, { headers = {}, customFetch, } = {}) {\n        this.url = url;\n        this.headers = headers;\n        this.fetch = resolveFetch(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @params token - the new jwt token sent in the authorisation header\n     */\n    setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - the name of the function to invoke\n     * @param invokeOptions - object with the following properties\n     * `headers`: object representing the headers to send with the request\n     * `body`: the body of the request\n     * `responseType`: how the response should be parsed. The default is `json`\n     */\n    invoke(functionName, invokeOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { headers, body } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n                const response = yield this.fetch(`${this.url}/${functionName}`, {\n                    method: 'POST',\n                    headers: Object.assign({}, this.headers, headers),\n                    body,\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') {\n                    return { data: null, error: new Error(yield response.text()) };\n                }\n                let data;\n                const { responseType } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n                if (!responseType || responseType === 'json') {\n                    data = yield response.json();\n                }\n                else if (responseType === 'arrayBuffer') {\n                    data = yield response.arrayBuffer();\n                }\n                else if (responseType === 'blob') {\n                    data = yield response.blob();\n                }\n                else {\n                    data = yield response.text();\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}